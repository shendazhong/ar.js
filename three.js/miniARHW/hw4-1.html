<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <title>hw4-1</title>
    <style type="text/css">
      #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 10px;
        text-align: center;
        color: #ffff00;
      }
      body {
        overflow: hidden;
        margin: 0px;
      }
    </style>
  </head>
  <body>
    <div id="info">
      請使用鍵盤按空白鍵 (Space) 射擊<br />
      與使用 ↑ ↓ ← → 移動砲台<br />
      或直接點擊按鈕調整<br />
      <button id="up" style="margin-top: 10px">↑</button>
      <button id="down">↓</button>
      <button id="left">←</button>
      <button id="right">→</button>
      <button id="shoot">shoot</button>
    </div>
    <script>
      var camera, scene, renderer;
      var cannon, clock, ball;
      var prePos, pos, vel, force;
      var x0, dx;

      init();
      animate();

      function init() {
        scene = new THREE.Scene();

        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x888888);
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(
          50,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.set(0, 150, 150);
        let controls = new THREE.OrbitControls(camera, renderer.domElement);
        var gridXZ = new THREE.GridHelper(200, 20, 'red', 'white');
        scene.add(gridXZ);

        ///////////////////////////////////////////////////////////
        window.addEventListener(
          'resize',
          function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          },
          false
        );

        cannon = makeCannon();
        scene.add(cannon);
        clock = new THREE.Clock();
        //scene.add(makeParabola(-1, 0, 30));

        //// settings //////////////////////
        let barrel = cannon.children[1];
        barrel.rotation.z = -Math.PI / 6; // barrel angle
        cannon.rotation.y = -Math.PI / 6;
        prePos = new THREE.Vector3();

        ball = new THREE.Mesh(
          new THREE.SphereGeometry(2, 8, 8),
          new THREE.MeshBasicMaterial({
            color: 'yellow',
            wireframe: true,
          })
        );
        scene.add(ball);

        window.addEventListener('keydown', function (e) {
          switch (e.key) {
            case 'ArrowRight':
              cannon.rotation.y -= Math.PI / 90;
              break;
            case 'ArrowLeft':
              cannon.rotation.y += Math.PI / 90;
              break;
            case 'ArrowDown':
              if (barrel.rotation.z > -1.5) barrel.rotation.z -= Math.PI / 90;
              break;
            case 'ArrowUp':
              if (barrel.rotation.z < -0.5) barrel.rotation.z += Math.PI / 90;
              break;
            case ' ':
              if (!ball) {
                ball = new THREE.Mesh(
                  new THREE.SphereGeometry(2, 8, 8),
                  new THREE.MeshBasicMaterial({
                    color: 'yellow',
                    wireframe: true,
                  })
                );
                scene.add(ball);
              }
              break;
          }
        });

        $('#up').mousedown(function () {
          if (barrel.rotation.z < -0.5) barrel.rotation.z += Math.PI / 90;
        });
        $('#down').mousedown(function () {
          if (barrel.rotation.z > -1.5) barrel.rotation.z -= Math.PI / 90;
        });
        $('#left').mousedown(function () {
          cannon.rotation.y += Math.PI / 90;
        });
        $('#right').mousedown(function () {
          cannon.rotation.y -= Math.PI / 90;
        });
        $('#shoot').mousedown(function () {
          if (!ball) {
            ball = new THREE.Mesh(
              new THREE.SphereGeometry(2, 8, 8),
              new THREE.MeshBasicMaterial({
                color: 'yellow',
                wireframe: true,
              })
            );
            scene.add(ball);
          }
        });
      }

      function makeCannon() {
        let cannon = new THREE.Group();
        let body = new THREE.Mesh(
          new THREE.SphereGeometry(
            10,
            20,
            20,
            Math.PI + Math.PI * 0.1,
            Math.PI * 1.8,
            0,
            Math.PI / 2
          ),
          new THREE.MeshNormalMaterial()
        );
        let barrelPart = new THREE.Group();
        let barrel = new THREE.Mesh(
          new THREE.CylinderGeometry(2, 2, 20, 18),
          new THREE.MeshNormalMaterial()
        );
        barrelPart.add(barrel);
        barrel.position.y = 10;

        cannon.add(body, barrelPart);
        return cannon;
      }
      function computeInitPosVel() {
        let barrel = cannon.children[1];
        const SPEED = 25;
        vel = barrel
          .localToWorld(new THREE.Vector3(0, 20, 0))
          .sub(barrel.localToWorld(new THREE.Vector3(0, 0, 0)))
          .setLength(SPEED);
        pos = barrel.localToWorld(new THREE.Vector3(0, 22, 0));
      }

      function makeParabola(a, b, c) {
        let xRange = (Math.sqrt(-a * c) * 2) / a;
        const N = 20;
        let dx = xRange / 20;

        let points = [];
        let x0 = b - xRange / 2;
        for (let i = 0; i <= N; i++) {
          xi = x0 + i * dx;
          yi = a * (xi - b) * (xi - b) + c;
          points.push(new THREE.Vector3(xi, yi, 0));
        }

        let geometry = new THREE.BufferGeometry().setFromPoints(points);
        let parabola = new THREE.Line(
          geometry,
          new THREE.LineDashedMaterial({ color: 'cyan' })
        );
        parabola.computeLineDistances(); // required for LineDashedMaterial
        return parabola;
      }

      function animate() {
        requestAnimationFrame(animate);
        renderer.render(scene, camera);

        if (pos === undefined) {
          computeInitPosVel();
          return;
        }
        if (pos.y < 0) return;

        let dt = clock.getDelta();

        // Euler's method
        if (ball) {
          let force = new THREE.Vector3(0, -10, 0);
          force.add(new THREE.Vector3(0, 0, 2));
          force.add(vel.clone().multiplyScalar(-0.125));
          vel.add(force.clone().multiplyScalar(dt));
          pos.add(vel.clone().multiplyScalar(dt));

          ball.position.copy(pos);
          ball.quaternion.setFromUnitVectors(
            new THREE.Vector3(0, 1, 0),
            pos.clone().sub(prePos).normalize()
          );
          if (ball.position.y < 0) {
            scene.remove(ball);
            pos = undefined;
            ball = undefined;
          }
        }
      }
    </script>
  </body>
</html>
